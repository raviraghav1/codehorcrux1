const Parts = [
  {
    text: "input: Refactor this code\n\nimport java.io.*;import java.util.*;public class Solution {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int t = sc.nextInt();        while (t-- > 0) {            int n = sc.nextInt();            int cost = findMinimumCost(n);            System.out.println(cost);        }    }    public static int findMinimumCost(int n) {        String binary = Integer.toBinaryString(n);        boolean isGood = isGood(binary);        if (isGood) {            return 0;        }        int cost = 0;        while (!isGood) {            n += 1;            binary = Integer.toBinaryString(n);            isGood = isGood(binary);            cost += 1;        }        return cost;    }public static boolean isGood(String binary) {    int state = 0;     for (int i = 0; i < binary.length(); i++) {        char current = binary.charAt(i);        if (state == 0 && current == '1') {            state = 1;         } else if (state == 1 && current == '0') {            state = 2;         } else if (state == 2 && current == '1') {            return false;         }    }    return true; }}",
  },
  {
    text: "output: import java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        while (t-- > 0) {\n            int n = sc.nextInt();\n            int cost = findMinimumCost(n);\n            System.out.println(cost);\n        }\n        sc.close();\n    }\n\n    public static int findMinimumCost(int n) {\n        String binary = Integer.toBinaryString(n);\n        if (isGood(binary)) {\n            return 0;\n        }\n\n        int cost = 0;\n        while (!isGood(binary)) {\n            n++;\n            binary = Integer.toBinaryString(n);\n            cost++;\n        }\n        return cost;\n    }\n\n    public static boolean isGood(String binary) {\n        int state = 0;\n        for (char current : binary.toCharArray()) {\n            if (state == 0 && current == '1') {\n                state = 1;\n            } else if (state == 1 && current == '0') {\n                state = 2;\n            } else if (state == 2 && current == '1') {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
  },
  {
    text: "input: refactor this code import React, { useState } from 'react';import SoftInput from '../components/SoftInput';import SoftButton from '../components/SoftButton';import Logo from '../assets/logo.png'import { LoginFunction } from '../api/Functions';import { useNavigate } from 'react-router-dom';import toast from 'react-hot-toast';export default function Login() {    const [data, setData] = useState({        email: '',        password: ''    })    const navigate = useNavigate()    const login = () => {        LoginFunction(data).then((res) => {            if(res) {                navigate('/');            localStorage.setItem('token', data.email)            }            else {                toast.error(\"User/Password Incorrect\")            }        }, err => { toast.error(\"User/Password Incorrect\") })    }    return                                                                                                                                                                 }",
  },
  {
    text: "output: import React, { useState } from 'react';\nimport SoftInput from '../components/SoftInput';\nimport SoftButton from '../components/SoftButton';\nimport Logo from '../assets/logo.png';\nimport { login } from '../api/Functions'; // Assuming the login function is exported from the api/Functions module\nimport { useNavigate } from 'react-router-dom';\nimport toast from 'react-hot-toast';\n\nexport default function Login() {\n    const [email, setEmail] = useState('');\n    const [password, setPassword] = useState('');\n    const navigate = useNavigate();\n\n    const handleLogin = async () => {\n        try {\n            const res = await login({ email, password });\n            if (res) {\n                navigate('/');\n                localStorage.setItem('token', email);\n            } else {\n                toast.error(\"User/Password Incorrect\");\n            }\n        } catch (error) {\n            toast.error(\"An error occurred while logging in.\");\n        }\n    };\n\n    return (\n        \n            \n                \n                \n                    \n                    \n                \n                    \n                    \n                \n                    \n                \n            \n        \n    );\n}",
  },

  {
    text: "input: for _ in range(int(input())):    N,M=map(int, input().split(' '))    sb = input().split(' ')    sbo = input().split(' ')    main_max1 =  sorted([int(x) for x in sb])    main_max_b = sorted([int(x) for x in sbo])    main_max1.sort(reverse=True)    main_max_b.sort(reverse=True)    if N < 4 or M < 4 or N+M<11:        print(\"-1\")    else:        team_batsmen = main_max1[:4]        team_bowlers = main_max_b[:4]        total_skill = sum(team_batsmen) + sum(team_bowlers)        l_bats = main_max1[4:]        n_lows = main_max_b[4:]        z = l_bats+n_lows        z.sort(reverse=True)        z_sum = sum(z[:3])        print(total_skill+z_sum)\n\nrefactor this code",
  },
  {
    text: 'output: ```python\ndef optimize_team_selection(num_batsmen, num_bowlers, batsman_skills, bowler_skills):\n    """\n    Optimizes team selection for cricket based on batsman and bowler skills.\n\n    Args:\n        num_batsmen (int): Number of batsmen required in the team.\n        num_bowlers (int): Number of bowlers required in the team.\n        batsman_skills (list[int]): List of batsman skill values.\n        bowler_skills (list[int]): List of bowler skill values.\n\n    Returns:\n        int: Total skill of the optimized team, or -1 if a valid team cannot be formed.\n    """\n\n    if num_batsmen < 4 or num_bowlers < 4 or num_batsmen + num_bowlers < 11:\n        return -1  # Invalid team size\n\n    # Sort skills in descending order\n    top_batsmen = sorted(batsman_skills, reverse=True)[:4]\n    top_bowlers = sorted(bowler_skills, reverse=True)[:4]\n\n    # Calculate total skill of top batsmen and bowlers\n    total_skill = sum(top_batsmen) + sum(top_bowlers)\n\n    # Combine and sort remaining players\n    remaining_players = sorted(top_batsmen[4:] + top_bowlers[4:], reverse=True)\n\n    # Add skill of top 3 remaining players\n    total_skill += sum(remaining_players[:3])\n\n    return total_skill\n\n# Get input from user\nnum_cases = int(input())\n\nfor _ in range(num_cases):\n    num_batsmen, num_bowlers = map(int, input().split())\n    batsman_skills = list(map(int, input().split()))\n    bowler_skills = list(map(int, input().split()))\n\n    optimal_skill = optimize_team_selection(num_batsmen, num_bowlers, batsman_skills, bowler_skills)\n    print(optimal_skill)\n```\n\n**Improvements:**\n\n- **Function Definition:** The code is encapsulated into a function `optimize_team_selection`, making it reusable and easier to understand.\n- **Clear Naming:** Meaningful variable and function names are used to enhance readability (e.g., `top_batsmen`, `total_skill`).\n- **Docstring:** A docstring is added to explain the function\'s purpose, parameters, and return value.\n- **Comments:** Comments are included to clarify specific steps or logic.\n- **Input Handling:** The input handling part remains similar for clarity.\n- **Efficiency:** Sorting is done only once for each skill set, potentially improving efficiency.',
  },

  {
    text: 'input: import React from "react";\nimport { Dropdown, Menu, Table } from "antd";\nimport { AnalyticsOutlined, DotsIcon } from "../../assets/icons";\nimport { EyeOutlined } from "@ant-design/icons";\nimport { EditOutlined } from "@ant-design/icons";\nimport { DeleteOutlined } from "@ant-design/icons";\n\nfunction CustomTable({\n  rows,\n  columns,\n  viewData,\n  EditData,\n  ShowDelete,\n  dataName,\n}) {\n  const actionMenu = (record) => {\n    if (dataName === "Ad Campaigns") {\n      return (\n        \n          \n          \n          \n        \n      );\n    } else {\n      return (\n        \n          \n          \n          \n        \n      );\n    }\n  };\n\n  const columnsWithAction = [\n    ...columns,\n    {\n      title: "Action",\n      key: "action",\n      render: (_, record) => {\n        return (\n          \n        );\n      },\n    },\n  ];\n\n  return (\n    \n  );\n}\n\nexport default CustomTable;',
  },
  {
    text: 'output: ```javascript\nimport React from "react";\nimport { Dropdown, Menu, Table } from "antd";\nimport { AnalyticsOutlined, DotsIcon } from "../../assets/icons";\nimport { EyeOutlined, EditOutlined, DeleteOutlined } from "@ant-design/icons";\n\nfunction CustomTable({ rows, columns, viewData, EditData, ShowDelete, dataName }) {\n  // Function to determine action menu items based on dataName\n  const getActionMenuItems = () => {\n    const commonItems = [\n      {\n        key: "view",\n        label: ',
  },
  {
    text: 'input: import React, { useState, useRef, useEffect } from "react";\nimport {\n  Text,\n  View,\n  StatusBar,\n  Image,\n  TextInput,\n  TouchableOpacity,\n} from "react-native";\nimport {\n  getAuth,\n  PhoneAuthProvider,\n  signInWithCredential,\n} from "firebase/auth";\nimport { getApp, initializeApp } from "firebase/app";\nimport {\n  FirebaseRecaptchaVerifierModal,\n  FirebaseRecaptchaBanner,\n} from "expo-firebase-recaptcha";\nimport BusImage from "../../assets/logo.webp";\nimport firebaseConfig from "../../config/firebaseConfig";\n\nconst Login = ({navigation }) => {\n  const recaptchaVerifier = useRef(null);\n  const [phoneNumber, setPhoneNumber] = useState("8870652361");\n  const [verificationId, setVerificationID] = useState("");\n  const [verificationCode, setVerificationCode] = useState("");\n  const [auth, setAuth] = useState();\n  const [firebaseConfig1, setFirebaseConfig1] = useState();\n  const [info, setInfo] = useState("");\n  const attemptInvisibleVerification = true;\n\n  async function initializeFirebaseApp() {\n    try {\n      initializeApp(firebaseConfig);\n    } catch (error) {\n      console.log("Initializing error ", error);\n    }\n\n    const app = await getApp();\n    const auth1 = getAuth(app);\n    await setAuth(auth1);\n    setFirebaseConfig1(app.options);\n  }\n\n  useEffect(() => {\n    initializeFirebaseApp();\n  }, []);\n\n  const handleSendVerificationCode = async () => {\n    try {\n      const phoneProvider = await new PhoneAuthProvider(auth);\n      const verificationId = await phoneProvider.verifyPhoneNumber(\n        `+91${phoneNumber}`,\n        recaptchaVerifier.current\n      );\n      setVerificationID(verificationId);\n      setInfo("Success : Verification code has been sent to your phone");\n    } catch (error) {\n      setInfo(`Error : ${error.message}`);\n    }\n  };\n\n  const handleVerifyVerificationCode = async () => {\n    try {\n      const credential = PhoneAuthProvider.credential(\n        verificationId,\n        verificationCode\n      );\n      await signInWithCredential(auth, credential);\n      setInfo("Success: Phone authentication successful"); \n      navigation.navigate("Welcome"); \n    } catch (error) {\n      setInfo(`Error : ${error.message}`); \n    }\n  };\n\n  const handleOnMessage = (event) => {\n    console.log(\'Message from WebView:\');\n  }\n\n  return (\n    \n  );\n};\n\nexport default Login;',
  },
  {
    text: "output: ```javascript\nimport React, { useState, useRef } from 'react';\nimport { Text, View, StatusBar, Image, TextInput, TouchableOpacity } from 'react-native';\nimport { getAuth, PhoneAuthProvider, signInWithCredential } from 'firebase/auth';\nimport { initializeApp } from 'firebase/app';\nimport { FirebaseRecaptchaVerifierModal, FirebaseRecaptchaBanner } from 'expo-firebase-recaptcha';\nimport BusImage from '../../assets/logo.webp';\nimport firebaseConfig from '../../config/firebaseConfig';\n\nconst Login = ({ navigation }) => {\n    const recaptchaVerifier = useRef(null);\n    const [phoneNumber, setPhoneNumber] = useState(\"8870652361\");\n    const [verificationId, setVerificationId] = useState(\"\");\n    const [verificationCode, setVerificationCode] = useState(\"\");\n    const [info, setInfo] = useState(\"\");\n    const attemptInvisibleVerification = true;\n\n    // Initialize Firebase app on component mount\n    React.useEffect(() => {\n        initializeApp(firebaseConfig);\n    }, []);\n\n    const auth = getAuth(); // Get auth instance after initialization\n\n    const handleSendVerificationCode = async () => {\n        try {\n            const phoneProvider = new PhoneAuthProvider(auth);\n            const verificationId = await phoneProvider.verifyPhoneNumber(\n                `+91${phoneNumber}`,\n                recaptchaVerifier.current\n            );\n            setVerificationId(verificationId);\n            setInfo(\"Success : Verification code has been sent to your phone\");\n        } catch (error) {\n            setInfo(`Error : ${error.message}`);\n        }\n    };\n\n    // ... rest of the component code ...\n};\n\nexport default Login;\n```\n\n**Improvements:**\n\n- **Firebase Initialization:** The `initializeApp` call is moved to a `useEffect` hook to ensure it's called only once when the component mounts. This avoids potential issues with repeated initialization.\n- **Auth Instance:** The `getAuth` call is made after initialization to ensure it uses the correct app instance. \n- **Removed Unnecessary State:** The `auth` and `firebaseConfig1` state variables were unnecessary and have been removed.\n- **Simplified Code:** The code is made more concise by removing unnecessary `async/await` and state updates.",
  },
 
  {
    text: 'input: import React, { useState, useEffect } from "react";\nimport { axiosInstance } from "../../axios";\nimport { TextField, Button } from "@mui/material";\nimport { useParams } from "react-router-dom";\nimport { toast } from "react-hot-toast";\nimport Styles from "./style.module.css";\n\nexport default function EditCustomerComponent() {\n\tconst [customerDetails, setCustomerDetails] = useState({});\n\tconst { id } = useParams();\n\n\tconst getCustomer = async () => {\n\t\tawait axiosInstance.get(`/customers/${id}/`).then(\n\t\t\t(res) => setCustomerDetails(res.data),\n\t\t\t(err) => {\n\t\t\t\tconsole.log(err);\n\t\t\t}\n\t\t);\n\t};\n\n\tconst saveCustomer = () => {\n\t\taxiosInstance.put(`/customers/${id}/`, customerDetails).then(\n\t\t\t(res) => toast.success("Customer Details Updated Successfully"),\n\t\t\t(err) => toast.error("Error Updating customer Data")\n\t\t);\n\t};\n\n\tuseEffect(() => {\n\t\tgetCustomer();\n\t}, []);\n\n\treturn (\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\tCustomer Details\n\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\n\t\t\t\t\tAccount Details\n\t\t\t\t\t\n\n\t\t\t\t\n\t\t\t\t\tAddress and Shipping\n\t\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n\t);\n}\n\nrefactor this code split the input component into json and render from it and also manage the state properly use try catch, remove unused functions and modules and imported libraries.\n\ndon\'t use like //other fields give me complete working code don\'t leave for the user to complete the code',
  },
  {
    text: 'input: import React, { useState, useEffect } from "react";\nimport { axiosInstance } from "../../axios";\nimport Form from "react-bootstrap/Form";\nimport Button from "react-bootstrap/Button";\nimport { Link } from "react-router-dom";\nimport { useNavigate } from "react-router-dom";\nimport Styles from "./style.module.css";\n\nexport default function CustomersComponent() {\n\tconst [customers, setCustomer] = useState([]);\n\tconst [searchData, setSearchData] = useState("");\n\n\tconst navigate = useNavigate();\n\n\tconst getCustomers = async () => {\n\t\tawait axiosInstance.get(`/customers/`).then((res) => setCustomer(res.data));\n\t};\n\n\tuseEffect(() => {\n\t\tgetCustomers();\n\t}, []);\n\n\tconst print = () => {\n\t\tvar bodya = document.body.innerHTML;\n\t\tvar printa = document.getElementById("print").innerHTML;\n\t\tdocument.body.innerHTML = printa;\n\t\twindow.print();\n\t\twindow.location.reload();\n\t};\n\n\treturn (\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\t{" "}\n\t\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t\t{customers\n\t\t\t\t\t\t\t.filter((dt) =>\n\t\t\t\t\t\t\t\tdt.customer_name\n\t\t\t\t\t\t\t\t\t.toLowerCase()\n\t\t\t\t\t\t\t\t\t.includes(searchData.toLowerCase())\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.map((data, id) => (\n\t\t\t\t\t\t\t\t navigate(`/customers/${data.id}`)}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t))}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tS.no\n\t\t\t\t\t\t\tCustomer Name\n\t\t\t\t\t\t\tContact Number\n\t\t\t\t\t\t\tGST number\n\t\t\t\t\t\t\tAddress\n\t\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t{id + 1}\n\t\t\t\t\t\t\t\t\t{data.customer_name}\n\t\t\t\t\t\t\t\t\t{data.contact}\n\t\t\t\t\t\t\t\t\t{data.gstno}\n\t\t\t\t\t\t\t\t\t{data.address}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\n\t\t\t\n\t\t\n\t);\n}',
  },
  {
    text: "input: // ... (rest of the component implementation)\n\ncomplete this",
  },
  {
    text: "output: ```javascript\n                                 navigate(`/customers/${customer.id}`)}>\n                                    {index + 1}\n                                    {customer.customer_name}\n                                    {customer.contact}\n                                    {customer.gstno}\n                                    {customer.address}\n                                \n                            ))}\n                         \n                     \n                \n            \n        \n    );\n}\n```\n\n**Explanation:**\n\n- **Table Row:** The `tr` element represents a table row, and each row is given a unique `key` using the customer's `id`. The `onClick` handler is attached to the row to navigate to the customer details page when clicked.\n- **Table Data:** The `td` elements display the customer data, including the serial number (index + 1), customer name, contact number, GST number, and address. \n- **Table Body:** The table rows are enclosed within a `tbody` element to indicate the main content of the table.\n- **Closing Tags:** The closing tags for the `table` and `div` elements are added to complete the component's structure.",
  },
  {
    text: "input: from .models import Job\nfrom .serializers import JobsSerializers\nfrom .check_auth import authendicate\nfrom rest_framework.response import Response\nfrom rest_framework.decorators import api_view\nfrom rest_framework import status\n\n@api_view(['GET'])\ndef fetchLocation(request):\n    token = request.headers.get('authorization')\n    user = authendicate(token)\n    if user['token_status'] == True:\n        x=[]\n        y = []\n        lo = Job.objects.all().values('location')\n        for d in lo:\n            if d['location'].lower() not in y:\n                x.append({'value': d['location'], 'label': d['location']})\n                y.append(d['location'].lower())\n        return Response(x, status=status.HTTP_200_OK)\n    else:\n        return Response({'status': 'Auth Failed'}, status=status.HTTP_401_UNAUTHORIZED)",
  },
  {
    text: "output: ```python\nfrom .models import Job\nfrom .serializers import JobsSerializers\nfrom .check_auth import authenticate  # Corrected typo\nfrom rest_framework.response import Response\nfrom rest_framework.decorators import api_view\nfrom rest_framework import status\n\n\n@api_view(['GET'])\ndef fetch_locations(request):  # Improved function name for clarity\n    \"\"\"\n    Fetch a list of unique job locations.\n    Authentication required. \n    \"\"\"\n    token = request.headers.get('authorization')\n    user = authenticate(token)\n\n    if user['token_status']:\n        locations = Job.objects.values_list('location', flat=True).distinct()\n        location_data = [{'value': location, 'label': location} for location in locations]\n        return Response(location_data, status=status.HTTP_200_OK)\n    else:\n        return Response({'status': 'Authentication Failed'}, status=status.HTTP_401_UNAUTHORIZED)\n```\n\n**Improvements:**\n\n- **Function Naming:** The function name is changed to `fetch_locations` for better clarity and adherence to Python naming conventions.\n- **Docstring:** A docstring is added to explain the purpose and authentication requirements of the view.\n- **Authentication:** The `authenticate` function (with corrected typo) is used for authentication.\n- **Location Retrieval:** The code now uses `values_list('location', flat=True).distinct()` to efficiently retrieve a list of unique locations without the need for manual filtering. \n- **Data Structure:** The location data is directly formatted into a list of dictionaries with `value` and `label` keys, as expected by the frontend.\n- **Response:** The response includes an appropriate status code and the list of locations.\n- **Error Handling:** An appropriate error message and status code are returned if authentication fails.",
  },
  { text: "input: " },
  { text: "output: " },
];

module.exports = {
  Parts,
};
